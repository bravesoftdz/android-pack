include("Conversion")

func create(entry)
	include("Constants")

	gvar(package_name)
	gvar(code_files, code_file)
	gvar(blk, blk_import, blk_class, blk_fields, blk_methods, blk_on_create, blk_on_destroy)
	gvar(blk_manifest, blk_manifest_app)
	
	register_types()
	
	package_name = 'com.hiasmproject'
	code_files = new array()
	
	blk = block.reg("result")
	
	blk_manifest = block.reggen()
	blk_manifest_app = block.reggen()
end

func destroy(entry)
	build_config = block.reggen()
	
	// Generate manifest
	block.reggen()
		.println('<?xml version="1.0" encoding="utf-8"?>')
		.println('<manifest package="' + package_name + '"')
        .println('	xmlns:android="http://schemas.android.com/apk/res/android">').inc()
			.copyhere(blk_manifest)
			.println('<application')
			.println('	android:allowBackup="true"')
			.println('	android:icon="@mipmap/ic_launcher"')
			.println('	android:label="@string/app_name"')
			.println('	android:supportsRtl="true"')
			.println('	android:theme="@style/AppTheme"')
        	.println('	android:hardwareAccelerated="true">').inc()
				.copyhere(blk_manifest_app)
			.println('</application>')
		.dec().println('</manifest>')
	.build('Elements\\Android\\code\\result\\hi\\AndroidManifest.xml')
	
trace(compiler())
	
	// Generate code files
	for(i = 0; i < code_files.size(); i++)
		cf = code_files[i]
		path = 'Elements\\Android\\code\\result\\hi\\' + code(cf[CODE_FILE_NAME]) + '.java'
		
		block.reggen()
			.println('package ',package_name,';').println('')
			.copyhere(cf[CODE_FILE_IMPORT]).println('')
			.copyhere(cf[CODE_FILE_BODY]).println(' {').inc()
				.copyhere(cf[CODE_FILE_FIELDS])
				.copyhere(cf[CODE_FILE_METHODS])
				
				.println('@Override')
				.println('protected void onCreate() {').inc()
					.copyhere(cf[CODE_FILE_ON_CREATE])
				.dec().println('}')
				
				.println('@Override')
				.println('protected void onDestroy() {').inc()
					.copyhere(cf[CODE_FILE_ON_DESTROY])
				.dec().println('}')
				
			.dec().println('}')
		.build(path)
		
		
		build_config.println('file_type="code_file" path="' + path + '"')
	end
	
	build_config.build('Elements\\Android\\code\\result\\hi\\buildconfig')
end

include("Codefile")

func add_method(name, header)
	class_methods = code_file[CODE_FILE_DYNAMIC_METHODS]

	method_idx = -1
	for(i = 0; i < class_methods.size(); i++)
		if(class_methods[i][DYNAMIC_METHOD_NAME] == val)
			method_idx = i
		end
	end
	
	if(method_idx == -1)
		mthd_block = block.reggen()
		mthd_block.print(header).println(' {').inc()
		
		mthd = new array().fill(16, '')
		mthd[DYNAMIC_METHOD_NAME]  = name
		mthd[DYNAMIC_METHOD_BLOCK] = method_block
		
		class_methods << mthd
		
		return(mthd_block)
	else
		return(class_methods[method_idx][DYNAMIC_METHOD_BLOCK])
	end
end

func import(import_class)
	if(pos(blk_import.ascode(), import_class, 0) == -1)
		blk_import.println('import ', code(import_class), ';')
	end
end